# BPF Subsystem Delta

## Verifier Invariants
- All memory accesses must be bounds-checked by verifier
- Register types tracked through program flow
- Stack slots must be initialized before use
- Helper functions have specific argument requirements

## BPF Map Operations
- Map lookups can return NULL
- Map updates need to check max_entries
- Spin locks in maps require bpf_spin_lock/unlock
- Per-CPU maps need bpf_get_cpu_ptr/put_cpu_ptr

## Reference Tracking
- Some helpers return "acquired" references
- Must release with corresponding release helper
- Verifier tracks reference state per register

## Context Access
- Context pointer is read-only
- Field access must be within ctx structure size
- Some fields require specific program types

## BPF Kernel Functions (kfuncs)
- __bpf_kfunc, BTF_KFUNCS*, KF_* flags, etc
- read `Documentation/bpf/kfuncs.rst` to better understand these

## Quick Checks
- Helpers marked with BPF_RET_PTR_TO_MAP_VALUE_OR_NULL need NULL checks
- ARG_PTR_TO_MEM arguments need size validation
- Tail calls limited to 33 levels
- Stack usage limited to 512 bytes

## BPF Skeleton API (Selftests)

### Generated Skeleton Functions
BPF skeletons are generated by `bpftool gen skeleton` and provide type-safe wrappers.
Each skeleton includes these functions (where `example` is the object name):

- `example__open()` - Opens BPF object (does not load programs)
- `example__load()` - Creates maps, loads and verifies all BPF programs
- `example__open_and_load()` - Combines open + load in one operation
- `example__destroy()` - Detaches, unloads programs, frees resources

### Skeleton Guarantees After Successful `__open_and_load()`

**IMPORTANT**: After successful `skel = example__open_and_load()`:
- The skeleton pointer is valid (not NULL/ERR_PTR)
- **ALL programs are loaded with valid FDs** (>= 0)
- **ALL maps are created with valid FDs** (>= 0)
- Skeleton fields like `skel->progs.prog_name` and `skel->maps.map_name` are guaranteed valid

This means:
- `bpf_program__fd(skel->progs.prog_name)` **CANNOT return negative** after successful load
- `bpf_map__fd(skel->maps.map_name)` **CANNOT return negative** after successful load
- **NO additional FD validation needed** when using skeleton-generated fields

### When FD Checks ARE Required

FD checks with `CHECK_FAIL(fd < 0)` or similar are needed when using:
- Manual lookup APIs: `bpf_object__find_program_by_name()` - can return NULL if name not found
- Manual lookup APIs: `bpf_object__find_map_by_name()` - can return NULL if name not found
- Old-style loading: `bpf_prog_test_load()` - different API contract

### Skeleton vs Manual Lookup Pattern

```c
// Skeleton pattern - NO FD checks needed after successful __open_and_load()
skel = example__open_and_load();
if (!ASSERT_OK_PTR(skel, "open_and_load"))
    return;
prog_fd = bpf_program__fd(skel->progs.my_prog);  // Cannot fail here
map_fd = bpf_map__fd(skel->maps.my_map);          // Cannot fail here

// Manual lookup pattern - FD checks REQUIRED (using modern ASSERT_* macros)
obj = bpf_object__open_file("example.o", NULL);
prog = bpf_object__find_program_by_name(obj, "my_prog");  // Can return NULL
if (!ASSERT_OK_PTR(prog, "find_program"))
    goto cleanup;
prog_fd = bpf_program__fd(prog);  // Can return negative if prog is invalid
if (!ASSERT_GE(prog_fd, 0, "bpf_program__fd"))
    goto cleanup;
```

## BPF Selftest Assertion Macros

### Modern ASSERT_*() Macros (Preferred)

**Use ASSERT_*() macros for all new tests and when updating existing tests.**

The modern ASSERT family includes type-specific macros like `ASSERT_OK()`, `ASSERT_ERR()`,
`ASSERT_EQ()`, `ASSERT_OK_PTR()`, `ASSERT_OK_FD()`, and many others. See
`tools/testing/selftests/bpf/test_progs.h` for the complete list.

### Deprecated CHECK() Macros (Avoid in New Code)

**DO NOT use in new tests or patches:**

- `CHECK(condition, tag, format...)` - **DEPRECATED** - Use `ASSERT_*()` instead
- `CHECK_FAIL(condition)` - **DEPRECATED** - Use `ASSERT_*()` instead
- `CHECK_ATTR(condition, tag, format...)` - **DEPRECATED** - Use `ASSERT_*()` instead

**Why ASSERT_*() is preferred:**
1. Uses static duration variable instead of requiring global `duration` variable
2. More specific and type-safe macros for different check types
3. Better error messages with actual vs expected values
4. Modern BPF selftest standard since 2020

**Migration example:**
```c
// OLD (deprecated):
static int duration = 0;  // Global/static variable required
if (CHECK(fd < 0, "open_fd", "failed to open: %d\n", errno))
    return;

// NEW (preferred):
if (!ASSERT_OK_FD(fd, "open_fd"))  // No duration variable needed
    return;
```

## BPF Patterns

Conditionally load these additional patterns
- BPF-001 (map operations with copy_map_value*) → `patterns/BPF-001.md`
- LIBBPF-001 (tools/lib/bpf*) → `patterns/LIBBPF-001.md`
