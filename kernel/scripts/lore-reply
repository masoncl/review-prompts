#!/usr/bin/env python3
"""
Usage:
    lore-reply [--no-dry-run] [--force] <COMMIT-REF>
    lore-reply [--no-dry-run] --mbox <MBOX-FILE> [MESSAGE-ID]

In the first form, b4 dig is used to find the message ID and download
the thread from lore.kernel.org.

In the second form, the mbox file is provided directly and patchid/reply
analysis is skipped. If MESSAGE-ID is omitted, the first message in the
mbox is used.

Options:
    --no-dry-run  Actually send the email (default is dry-run)
    --force       Skip patch-id verification and claude analysis
    --mbox FILE   Use existing mbox file instead of downloading

Default is --dry-run (git send-email will not actually send).
"""

import sys
import os
import re
import shutil
import subprocess
import tempfile
from email import policy
from email.parser import BytesParser
from urllib.parse import quote

def dig_commit(commit_ref: str) -> tuple[str, str]:
    """Use b4 dig to find the msgid and download mbox for a commit.

    Returns (msgid, mbox_path).
    """
    tmpdir = tempfile.mkdtemp(prefix="lore-dig-")
    mbox_path = os.path.join(tmpdir, "thread.mbox")

    print(f"Searching for patch on lore.kernel.org...")
    result = subprocess.run(
        ["b4", "dig", "-m", mbox_path, "-c", commit_ref],
        capture_output=True,
        text=True,
    )
    if result.returncode != 0:
        shutil.rmtree(tmpdir)
        print(result.stderr, end='')
        # Get commit subject for manual search suggestion
        subject_result = subprocess.run(
            ["git", "log", "-1", "--format=%s", commit_ref],
            capture_output=True,
            text=True,
        )
        if subject_result.returncode == 0 and subject_result.stdout.strip():
            subject = subject_result.stdout.strip()
            encoded_subject = quote(f'"{subject}"')
            print(f"Try searching manually: https://lore.kernel.org/all/?q=s:{encoded_subject}")
        sys.exit(1)
    print(f"Downloaded thread to {mbox_path}")

    # Look for the patch.msgid.link URL in the output
    msgid = None
    for line in result.stdout.splitlines():
        if "patch.msgid.link/" in line:
            # Extract msgid from URL like https://patch.msgid.link/20260107141015.25819-16-mark@harmstone.com
            msgid = line.split("patch.msgid.link/")[-1].strip()
            break

    if not msgid:
        shutil.rmtree(tmpdir)
        print(f"Could not find msgid for commit {commit_ref}. b4 dig output:\n{result.stdout}")
        # Get commit subject for manual search suggestion
        subject_result = subprocess.run(
            ["git", "log", "-1", "--format=%s", commit_ref],
            capture_output=True,
            text=True,
        )
        if subject_result.returncode == 0 and subject_result.stdout.strip():
            subject = subject_result.stdout.strip()
            encoded_subject = quote(f'"{subject}"')
            print(f"Try searching manually: https://lore.kernel.org/all/?q=s:{encoded_subject}")
        sys.exit(1)

    if not os.path.exists(mbox_path):
        shutil.rmtree(tmpdir)
        raise SystemExit(f"b4 dig did not create mbox file")

    return msgid, mbox_path


def summarize_replies(msgid: str, mbox_path: str, force: bool = False) -> None:
    """Use claude to summarize replies in the mbox."""
    if force:
        return

    review_file = "./review-inline.txt"
    review_context = ""
    if os.path.exists(review_file):
        review_context = f". Also check if any of the replies relate to the review in {review_file}, and whether anyone has reported a similar bug to what is described in {review_file}"

    prompt = f"Summarize replies to message id {msgid} in mbox {mbox_path}{review_context}"
    print("Analyzing thread replies...")
    result = subprocess.run(
        ["claude", "--model", "haiku", "-p", prompt],
        capture_output=True,
        text=True,
    )
    if result.returncode == 0 and result.stdout.strip():
        print("Reply summary:")
        print(result.stdout)
        print()
        response = input("Continue? [Y/n] ").strip().lower()
        if response == 'n':
            sys.exit(0)


def find_message_in_mbox(mbox_path: str, msgid: str):
    """Find a message by Message-ID in an mbox file."""
    target_msgid = f"<{msgid}>" if not msgid.startswith("<") else msgid

    # Parse each message with email.policy.default to get EmailMessage objects
    # which support get_body()
    with open(mbox_path, "rb") as f:
        content = f.read()

    # Split mbox into individual messages (separated by "From " lines)
    messages = re.split(rb'^From ', content, flags=re.MULTILINE)

    for i, msg_bytes in enumerate(messages):
        if i == 0 and not msg_bytes.strip():
            continue
        if i > 0:
            msg_bytes = b'From ' + msg_bytes

        try:
            msg = BytesParser(policy=policy.default).parsebytes(msg_bytes)
            msg_msgid = msg.get("Message-ID", "")
            if msg_msgid == target_msgid or msg_msgid == msgid:
                return msg
        except Exception:
            continue

    return None


def get_first_message_in_mbox(mbox_path: str):
    """Get the first message from an mbox file."""
    with open(mbox_path, "rb") as f:
        content = f.read()

    # Split mbox into individual messages (separated by "From " lines)
    messages = re.split(rb'^From ', content, flags=re.MULTILINE)

    for i, msg_bytes in enumerate(messages):
        if i == 0 and not msg_bytes.strip():
            continue
        if i > 0:
            msg_bytes = b'From ' + msg_bytes

        try:
            msg = BytesParser(policy=policy.default).parsebytes(msg_bytes)
            return msg
        except Exception:
            continue

    return None


def get_patch_id(input_bytes: bytes) -> str:
    """Compute git patch-id from patch content."""
    result = subprocess.run(
        ["git", "patch-id", "--stable"],
        input=input_bytes,
        capture_output=True,
    )
    if result.returncode != 0:
        return ""
    # Output format: "<patch-id> <commit-id>\n"
    parts = result.stdout.decode().strip().split()
    return parts[0] if parts else ""


def get_commit_patch_id(commit_ref: str) -> str:
    """Get patch-id for a commit."""
    # Use format-patch to get the same format as lore emails
    show = subprocess.run(
        ["git", "format-patch", "-1", "--stdout", commit_ref],
        capture_output=True,
    )
    if show.returncode != 0:
        raise SystemExit(f"git format-patch failed for {commit_ref}")
    return get_patch_id(show.stdout)


def verify_patch_id(msg, mbox_path: str, commit_ref: str) -> None:
    """Verify that the email patch matches the commit."""
    # Get the decoded body content for patch-id comparison
    # The email might be quoted-printable encoded
    body = msg.get_body(preferencelist=('plain',))
    if body:
        email_content = body.get_content().encode('utf-8')
    else:
        # Fallback to raw bytes
        email_content = msg.as_bytes()

    email_patch_id = get_patch_id(email_content)
    commit_patch_id = get_commit_patch_id(commit_ref)

    if not email_patch_id:
        print("Warning: could not compute patch-id from email")
        return
    if not commit_patch_id:
        print("Warning: could not compute patch-id from commit")
        return

    if email_patch_id != commit_patch_id:
        print(
            f"Patch-id mismatch!\n"
            f"  Email:  {email_patch_id}\n"
            f"  Commit: {commit_patch_id}\n"
        )

        # Get a summary of the differences using claude
        prompt = f"Briefly explain the differences between the patch in {mbox_path} and git commit {commit_ref}. Conclude whether the patches are basically the same or substantially different. Be concise."
        print("Analyzing patch differences...")
        result = subprocess.run(
            ["claude", "--model", "haiku", "-p", prompt],
            capture_output=True,
            text=True,
        )
        if result.returncode == 0 and result.stdout.strip():
            print("Difference summary:")
            print(result.stdout)
        else:
            print("(Could not generate difference summary)")

        print()
        response = input("Continue anyway? [y/N] ").strip().lower()
        if response != 'y':
            print("Use --force to skip this check entirely.")
            sys.exit(1)
        return

    print(f"Verified patch-id: {email_patch_id}")


def make_reply_file(orig_msg, msgid: str) -> str:
    fd, path = tempfile.mkstemp(prefix="lore-reply-", suffix=".txt")
    os.close(fd)

    orig_subject = orig_msg.get("Subject", "")
    # Decode RFC 2047 encoded subject if necessary
    if orig_subject:
        orig_subject = str(orig_subject)
    if orig_subject and not orig_subject.lower().startswith("re:"):
        subject = f"Re: {orig_subject}"
    else:
        subject = orig_subject or "(no subject)"

    in_reply_to = orig_msg.get("Message-ID") or f"<{msgid}>"
    references = orig_msg.get("References", "")
    if references:
        references = f"{references} {in_reply_to}"
    else:
        references = in_reply_to

    with open(path, "w", encoding="utf-8", newline="\n") as f:
        # Reply-To takes precedence over From for the To header
        reply_to = orig_msg.get("Reply-To") or orig_msg.get("From")
        orig_to = orig_msg.get("To")
        orig_cc = orig_msg.get("Cc")
        orig_from = orig_msg.get("From")

        # Build Cc list from original To and Cc
        cc_parts = []
        if orig_to:
            cc_parts.append(str(orig_to))
        if orig_cc:
            cc_parts.append(str(orig_cc))
        cc_combined = ", ".join(cc_parts) if cc_parts else None

        if reply_to:
            f.write(f"To: {reply_to}\n")
        if cc_combined:
            f.write(f"Cc: {cc_combined}\n")

        f.write(f"Subject: {subject}\n")
        f.write(f"In-Reply-To: {in_reply_to}\n")
        f.write(f"References: {references}\n")
        f.write("\n")

        # Attribution line
        if orig_from:
            f.write(f"{orig_from} wrote:\n")

        # Quote the original message body
        body = orig_msg.get_body(preferencelist=('plain',))
        if body:
            body_text = body.get_content()
            for line in body_text.splitlines():
                f.write(f"> {line}\n")

    return path

def main(argv):
    dry_run = True
    force = False
    mbox_file = None

    # Simple arg parsing: optional flags then args
    args = list(argv)
    while args and args[0].startswith("--"):
        if args[0] == "--no-dry-run":
            dry_run = False
            args = args[1:]
        elif args[0] == "--force":
            force = True
            args = args[1:]
        elif args[0] == "--mbox":
            args = args[1:]
            if not args:
                print("--mbox requires a file argument", file=sys.stderr)
                sys.exit(1)
            mbox_file = args[0]
            args = args[1:]
        else:
            print(f"Unknown option: {args[0]}", file=sys.stderr)
            sys.exit(1)

    # --mbox mode optionally takes MESSAGE-ID, otherwise COMMIT-REF required
    if mbox_file:
        if len(args) > 1:
            print(f"Usage: {sys.argv[0]} [--no-dry-run] --mbox <MBOX-FILE> [MESSAGE-ID]", file=sys.stderr)
            sys.exit(1)
        mbox_path = mbox_file

        if args:
            # MESSAGE-ID provided, find that specific message
            msgid = args[0]
            orig_msg = find_message_in_mbox(mbox_path, msgid)
            if not orig_msg:
                raise SystemExit(f"Could not find message {msgid} in mbox")
        else:
            # No MESSAGE-ID, use the first message
            orig_msg = get_first_message_in_mbox(mbox_path)
            if not orig_msg:
                raise SystemExit(f"Could not find any message in mbox")
            msgid = orig_msg.get("Message-ID", "").strip("<>")
    else:
        if len(args) != 1:
            print(f"Usage: {sys.argv[0]} [--no-dry-run] [--force] <COMMIT-REF>", file=sys.stderr)
            sys.exit(1)

        commit_ref = args[0]
        msgid, mbox_path = dig_commit(commit_ref)
        mbox_dir = os.path.dirname(mbox_path)
        print(f"Found msgid: {msgid}")
        print(f"https://lore.kernel.org/all/{msgid}")

        try:
            # Summarize any replies in the thread
            summarize_replies(msgid, mbox_path, force)

            # Find the specific message in the mbox
            orig_msg = find_message_in_mbox(mbox_path, msgid)
            if not orig_msg:
                raise SystemExit(f"Could not find message {msgid} in mbox")

            if not force:
                verify_patch_id(orig_msg, mbox_path, commit_ref)
        finally:
            shutil.rmtree(mbox_dir)

    reply_path = make_reply_file(orig_msg, msgid)

    cmd = [
        "git", "send-email",
        "--annotate",
        "--to", "",
    ]
    if dry_run:
        cmd.append("--dry-run")
    cmd.append(reply_path)

    print("Running:", " ".join(cmd))
    subprocess.run(cmd, check=True)

if __name__ == "__main__":
    main(sys.argv[1:])
