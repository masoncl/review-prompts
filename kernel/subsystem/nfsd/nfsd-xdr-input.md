# XDR Input Trust Boundaries

Failing to validate data decoded from XDR streams allows a malicious or
buggy NFS client to trigger buffer overflows, out-of-bounds reads, or
kernel crashes via crafted RPC arguments.

## Untrusted Data Sources

All data decoded from XDR streams (`xdr_stream_decode_*` calls) is
untrusted network input. Specific categories requiring validation:

- **String lengths** in NFSv3/v4 compound arguments — must be checked
  against protocol maximums before allocation or copy.
- **Array and vector counts** from READ/WRITE operations — unbounded
  counts can exhaust memory or overflow page vectors; see
  `nfsd_iter_read()` in `fs/nfsd/vfs.c` which bounds the loop with
  `rq_maxpages` and `rq_page_end`.
- **Offsets and lengths** in I/O operations — must not exceed file size
  limits or cause integer overflow when combined.
- **Client-provided file handles** — untrusted until validated by
  `fh_verify()` in `fs/nfsd/nfsfh.c`.
- **Callback arguments from client** — data decoded in
  `fs/nfsd/nfs4callback.c` (e.g., `decode_cb_fattr4()`,
  `nfs4_xdr_dec_cb_getattr()`) comes from the client acting as a
  callback server.
- **Administrative API inputs** — data from `fs/nfsd/nfsctl.c` and
  `fs/nfsd/netlink.c` originates from userspace.

## Trusted Data Sources

These do not require defensive validation within NFSD:

- **Post-verify file handle fields** — `fh_dentry` and `fh_export`
  after a successful `fh_verify()` call.
- **Auto-generated XDR output** — `nfs4xdr_gen.c` generated by xdrgen;
  the generated encode/decode functions handle wire-format details
  correctly by construction.
- **Internal state machine values** — state transitions managed by NFSD
  itself (e.g., stateid states, client confirmed/unconfirmed).
- **Kernel VFS layer returns** — error codes and data from VFS
  operations are kernel-internal.
