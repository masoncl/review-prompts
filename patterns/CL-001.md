# CL-001: Lock type and ordering

**Risk**: Deadlock/sleep bug

**When to check:** Mandatory when locking is used

Place each step defined below into TodoWrite.

**Mandatory lock type validation:**
- step 1: read entire function definition when locking is used
  - Output: function name, and a random line from anywhere in the definition
    - you must prove you read the function
- step 2: check all locks in modified functions, even if they didn't change
  - Output: locked variable and location
- step 3: never sleep (mutex/rwsem/schedule/sleeping allocations) in atomic context
  - Output: locks held in atomic context
- step 4: use _irqsave if any lock holder is called from IRQ context
  - Output: locks called from IRQ context
- step 5: check to make sure all users properly select _irq variants
  - Output: irq requirements found for each lock
- step 6: document and verify lock ordering when multiple locks held (verify no ABBA)
  - Output: lock ordering rules disocvered
- step 7: verify trylockâ†’lock conversion does not introduce deadlock scenarios
  - Output: each trylock->lock conversion
- step 8: verify all error paths release or hand off acquired locks
  - Output: quote each error path and verify lock state at exit

**After analysis:** Issues found: [none OR list]
