# CS-001: Callee analysis (down the stack)

**Risk**: Lock violations, resource leaks, uninitialized variables

**When to check**: Required for all non-trivial changes

**Pattern-specific TodoWrite fields**:
- Call chain traced: Level -N [callerfuncN] -> Level -1 [callerfuncA] -> Level 1: [funcA] -> [funcB at line], Level 2: [funcB] -> [funcD]
- Lock requirements per function: [funcB] requires [locks] - [caller provides? YES/NO]
- Locks held at return per function: [funcA] holds [locks] - [matches expectation? YES/NO]
- Return value handling: [funcA] checks [NULL/ERR_PTR/negative/positive] - [all variants? YES/NO]
- Error paths traced through functions: [path through chain] - [locks handled? YES/NO]
- Memory regions passed: [ pointer variable(s) in caller ] -> [ pointers in callee ]
- Resource propagation: [name] - initialized/locked/freed [YES/NO] - [final location]
- Resource state expectations: [funcA] passes [resource1] - Expects [describe], Actually [describe], Match [YES/NO]
- Variable/field initialization: [name] - [initialized before use? YES/NO] - [where]

**Callee traversal process**:
- Step callee.1: Always identify all direct callees in modified functions, track in TodoWrite
- Step callee.2: For each callee, always load entire function definition
- Step callee.3: Always trace 2-3 levels deep, adding callees to TodoWrite as discovered
- Step callee.4: Always apply all checks below to each callee in the chain
- Step callee.5: Add the modified function to the TodoWrite so all of these checks happen there as well

Caller traversal process:
- step caller.1: identify all direct callers, track in TodoWrite
- step caller.2: for each caller, always load function definition
- step caller.3: for callers that propagate return value, add their callers to TodoWrite
- step caller.5: repeat recursively until no more propagation
- step caller.6: apply all checks below to every caller

**Mandatory Lock requirements**:
- You must always verify proper locks are held based on requirements in every tracked function
- track lock requirements found for each function in TodoWrite
- track all lock requirements, even if they didn't change
- ensure functions take and release locks as expected by caller
- if locks are changed or dropped ruing the call, make sure code properly revalidates state under the new lock
- ensure caller provides all locks required by callees

**Mandatory locking in error path validation**:
- For every lock acquired, you must trace every error path through tracked functions, ensuring locks properly released/handed off
- track in the TodoWrite each error path traced through all tracked functions
- track in the TodoWrite all error paths in all functions tracked, even if they didn't change
- ensure locks are freed or held as required by the call stack

**Mandatory resource propagation validation**:
- You must trace resource ownership through function boundaries (where does resource end up?)
- track in TodoWrite each resource flow through tracked functions
- track in TodoWrite each allocation through kmalloc/kcalloc/kzalloc and related vmalloc APIs
  - track in TodoWrite any variables used to control the size of the allocation
    - Trace callers to find every possible value of the size parameter passed
  - If the size was potentially 0, report potential crash dereferencing ZERO_SIZE_PTR
- track in TodoWrite all resources through tracked functions, even if they didn't change
- track in TodoWrite whenever multiple pointers reference the same memory region
  - Track original allocation in TodoWrite
  - Track every variable referencing the memory in TodoWrite
  - Track every write into the memory through every variable in TodoWrite
  - track variables in callees pointing into shared memory in the TodoWrite as well
  - As pointers change in loops, track exactly which address they point to in TodoWrite
    - Ex: for (i = 0; i < count; i++, ptr++) ptr->field = value;
      - where does ptr point after each iteration?
      - how does ptr->field = value impact memory visible to other pointers into that same memory
  - Determine how setting ptrA->value will impact the memory visible to ptrB and all other pointers
  - This tracking will be used in later patterns as well.  They will reference it is MULTI_POINTER_MEMORY_TRACKING
- verify resources are properly initialized
- verify resources are properly locked and unlocked
- verify resources are properly freed

**Mandatory initialization delegation**:
- You must ensure variables and fields are initialized before reading
- track in TodoWrite each variable/field and initialization status per function tracked
- track in TodoWrite all initializations through tracked functions, even if they didn't change
- verify initialization before read
- track in TodoWrite uninitialized variables into tracked functions and verify they initialize before use
- track in TodoWrite uninitialized variables received from callers and verify initialization before use

**Mandatory Self-verification gate:**

**Pattern-specific questions**:
  1. Have you traced 2-3 levels deep for EVERY modified function? [yes/no]
  2. How many callees have missing lock requirements? [number]
  3. Have you traced ALL error paths through callees for lock handling? [yes/no]
  4. How many resources are not properly initialized/locked/freed? [number]
  5. How many variables/fields are used before initialization? [number]
  6. How many variables and memory allocations did you track in MULTI_POINTER_MEMORY_TRACKING? [number]
  7. How many zero sized slab/vmalloc allocations were done? [number]


If you cannot answer ALL questions with evidence, RESTART CS-001 from the beginning.
