# RM-007: Object cleanup and reinitialization

**Risk**: Incomplete initialization

**When to check**: Mandatory when objects are freed, torn down or unregistered

**Pattern-specific TodoWrite fields**:
- Objects torn down: [name] - [type] - [freed or returned to pool/global]
- Reuse scenario (pooled/global): All fields reinitialized? [YES/NO - which missing]
- Pointer fields set to NULL after freeing: [YES/NO - which missing]
- Use-after-free prevention: Structure fields with freed resources, pointer fields nulled

**Mandatory cleanup and reinit validation:**
- step 1: read full function definition
- step 2: track every object torn down in the TodoWrite
- step 3: if they are not freed, but instead returned to a pool or are global variables
  - check to make sure all fields in the object are fully initialized when the object is setup for reuse
- step 4: when freeing/destroying resources referenced by structure fields, ensure the pointer fields are set to NULL to prevent use-after-free on structure reuse
  - ex: unregister_foo() { foo->dead = 1; free(foo->ptr); add to list}
        register_foo() { pull from list ; skip allocation of foo->ptr; foo->ptr->use_after_free;}
  - Assume [kv]free(); [kv]malloc(); and related APIs handle this properly unless you find proof initialization is skipped

**Mandatory Self-verification gate:**

**Pattern-specific questions**:
  1. How many pooled/global objects have fields not reinitialized on reuse? [number]
  2. How many pointer fields are not set to NULL after freeing? [number]

If you cannot answer ALL questions with evidence, RESTART RM-007 from the beginning.

**Note**: For checking if callees initialize variables, see CS-001
