# RM-010: Scope-based cleanup helper usage

**Risk**: Resource leak, use-after-free, incorrect cleanup ordering

**When to check**: mandatory when cleanup.h helpers (__free, guard, DEFINE_FREE, DEFINE_GUARD) are used

**Pattern-specific TodoWrite fields**:
**Common Location**: Functions using __free, guard(), DEFINE_FREE, DEFINE_GUARD, no_free_ptr, return_ptr

- Cleanup variables: [count] - [list types/resources]
- Goto mixing: [YES/NO - if YES, location]
- Definition-initialization split: [YES/NO - if YES, location]
- operation ordering: [ordered list]
- Guard scope: [location in function]
- Ownership transfer: [uses no_free_ptr/return_ptr - YES/NO]

**Mandatory cleanup validation:**
- ensure no mixing of goto error patterns with cleanup helpers in same function
- ensure all cleanup-annotated variables defined with initialization in single statement
- ensure LIFO cleanup order preserved (locks acquired before resources)
- ensure guard() scope matches intended lock lifetime (block scope awareness)
- ensure no_free_ptr()/return_ptr() used when transferring ownership
- ensure ERR_PTR()-aware cleanup functions when error pointers possible

**Mandatory Self-verification gate:**

**Pattern-specific questions** (in addition to core questions):
  1. How many cleanup-annotated variables did you find? [number]
  2. How many instances of goto mixed with cleanup helpers? [number]
  3. How many definition-initialization splits? [number]
  4. Is LIFO ordering correct for all interdependent resources? [YES/NO]

If you cannot answer ALL questions with evidence, RESTART RM-010 from the beginning.
