# ZC-001: Zero-copy buffer lifetime validation

**Risk**: Use-after-free when registered buffers are released while zero-copy transmission is still using them

**When to check**: Mandatory when zero-copy operations (`IORING_OP_SEND_ZC`, `IORING_OP_SENDMSG_ZC`, or operations with `MSG_ZEROCOPY`) use registered buffers (IORING_RECVSEND_FIXED_BUF flag or io_import_reg_vec/io_import_reg_buf calls)

**Pattern-specific TodoWrite fields**:
- Zero-copy operations found: [opcode] - [fixed buffer usage] - [buf_node attachment point]
- Buffer import sites: [function] - [imports to req or notif] - [correct/incorrect]
- Cleanup paths: [function] - [cleans req or notif] - [timing relative to transmission]

**Mandatory zero-copy buffer lifetime validation:**

- step 1: Identify all zero-copy operations in the diff
  - Search for: IORING_OP_SEND_ZC, IORING_OP_SENDMSG_ZC, MSG_ZEROCOPY flag
  - Check for: IORING_RECVSEND_FIXED_BUF flag usage
  - Track each operation in TodoWrite

- step 2: For each zero-copy operation using registered buffers, identify buffer import calls
  - Direct imports: io_import_reg_buf(), io_import_reg_vec()
  - These functions call io_find_buf_node() which attaches buf_node via io_req_assign_buf_node()
  - Track which struct io_kiocb pointer is passed to the import function
  - Track each import site in TodoWrite

- step 3: Verify buffer import attachment point
  - Find the notif allocation: io_alloc_notif() typically stored in sr->notif or zc->notif
  - Check which io_kiocb is passed to buffer import functions:
    - CORRECT: io_import_reg_buf(sr->notif, ...) or io_import_reg_vec(..., sr->notif, ...)
    - INCORRECT: io_import_reg_buf(req, ...) or io_import_reg_vec(..., req, ...)
  - The buf_node MUST be attached to the notif, not the request
  - Track each attachment in TodoWrite

- step 4: Trace request and notif lifetimes
  - Request completion: Find where io_req_set_res() or io_req_complete() is called
    - This marks when the request completes to userspace
    - req cleanup happens shortly after (io_req_msg_cleanup, io_dismantle_req)
  - Notif completion: Find where io_notif_flush() is called
    - This initiates notif completion but doesn't wait for transmission
    - Actual completion happens in io_tx_ubuf_complete() callback from network/block layer
  - Track completion points in TodoWrite

- step 5: Verify cleanup timing
  - When buf_node is attached to req:
    - req completes → io_dismantle_req() → io_put_rsrc_node(req->buf_node)
    - Buffer reference is dropped while zero-copy transmission may still be in flight
    - **This is a BUG**
  - When buf_node is attached to notif:
    - req completes → notif still alive → transmission continues
    - Network stack calls io_tx_ubuf_complete() when done
    - notif completes → io_dismantle_req() → io_put_rsrc_node(notif->buf_node)
    - Buffer reference is dropped after transmission completes
    - **This is CORRECT**

- step 6: Check for existing non-vectored implementations
  - For new vectored zero-copy operations, compare with non-vectored equivalents:
    - IORING_OP_SEND_ZC uses io_send_zc_import() which does io_import_reg_buf(sr->notif, ...)
    - IORING_OP_SENDMSG_ZC should follow the same pattern
  - Vectored and non-vectored must have consistent lifetime management
  - Track comparisons in TodoWrite

**Mandatory Self-verification gate:**

**Pattern-specific questions**:
  1. How many zero-copy operations were found? [number]
  2. How many buffer import sites were tracked in TodoWrite? [number]
  3. For each import site, which io_kiocb receives the buf_node? [req or notif for each]
  4. How many import sites incorrectly attach buf_node to req? [number]
  5. For incorrect attachments, what is the time gap between req completion and expected transmission completion? [unbounded/uncertain]
  6. Does the non-vectored equivalent exist and use correct attachment? [yes/no, details]

If you cannot answer ALL questions with evidence, RESTART ZC-001 from the beginning.

**Common Bug Pattern**:
```c
// INCORRECT - buf_node attached to req
int io_sendmsg_zc(...) {
    ret = io_import_reg_vec(ITER_SOURCE, &kmsg->msg.msg_iter, req,  // BUG: using req
                            &kmsg->vec, uvec_segs, iovec_off, issue_flags);
    // req completes before transmission finishes, releasing buffers
}

// CORRECT - buf_node attached to notif
int io_send_zc_import(...) {
    sr->notif->buf_index = req->buf_index;
    ret = io_import_reg_buf(sr->notif, &kmsg->msg.msg_iter, ...);  // GOOD: using sr->notif
    // notif lives until transmission completes via io_tx_ubuf_complete()
}
```

**Verification Evidence Required**:
- Code path showing req completion point
- Code path showing notif completion point
- Proof that buf_node is attached to correct io_kiocb
- Comparison with equivalent non-vectored implementation (if exists)
