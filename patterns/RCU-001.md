#### RCU-001: Remove before reclaim ordering

**Risk**: Use-after-free

**Details**: Objects must be removed from RCU-protected data structures before calling `call_rcu()` or `synchronize_rcu()`. The reclaim operation can be `kfree()`, releasing to a pool, or any other form of resource release.

## Correct Order

1. **Remove from data structure FIRST** - prevents new readers from finding the object
2. **call_rcu() or synchronize_rcu()** - waits for existing readers to complete
3. **Reclaim the resource** (in callback or after synchronize_rcu)

Use the appropriate removal helpers: `hlist_del_rcu()`, `list_del_rcu()`, `rhashtable_remove_fast()`, etc.

## WRONG pattern (causes UAF)

```c
call_rcu(&obj->rcu, free_callback);

// In callback:
void free_callback(struct rcu_head *rhp) {
    struct obj *obj = container_of(rhp, struct obj, rcu);
    remove_from_data_structure(obj);  // WRONG: too late!
    kfree(obj);
}
```

**Why this is wrong:** New RCU readers that start AFTER the grace period but BEFORE `remove_from_data_structure()` executes can still find the object via lookup. When `kfree()` runs, these readers access freed memory.

## CORRECT pattern

```c
hlist_del_rcu(&obj->node);  // No new readers can find it
call_rcu(&obj->rcu, free_callback);

// In callback:
void free_callback(struct rcu_head *rhp) {
    struct obj *obj = container_of(rhp, struct obj, rcu);
    kfree(obj);  // Safe: all readers done
}
```

## Key Principle

`call_rcu()` only waits for readers that existed when it was called. It provides NO protection against readers that start after the grace period. The removal must happen before `call_rcu()` to prevent new readers from finding the object.
