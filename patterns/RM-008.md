# RM-008: Variable and field initialization

**Risk**: uninit memory usage

**When to check**: Mandatory when any variables or structure members are read

**Important context**:
- global variables and static variables are zero filled automatically
- slab and vmalloc APIs have variants that zero fill, and __GFP_ZERO gfp mask does as well
- list_add(new, head) calls (and others in the list_head API) initialize `new` by writing to it, but `head` must have been previously initialized.
- kmem_cache_create() can use an init_once() function to initialize slab objects
  - this only happens on the first allocation, and protects us from garbage in the struct

Place each step defined below into TodoWrite.

**Mandatory: Mempool/Slab allocation without constructors**
- For `mempool_alloc()` or `kmem_cache_alloc()` calls:
  - Output: call, line number
  - Find the cache creation and check if constructor is NULL
  - If NULL, assume ENTIRE structure contains garbage
  - Check what fields are explicitly initialized after allocation
  - Flag ANY field read before initialization

**Mandatory initialization validation:**
- step 1: read full function definitions
  - Output: function name, and a random line from anywhere in each definition
    - you must prove you read the function
- step 2: Find and use MULTI_POINTER_MEMORY_TRACKING from CS-001
- step 3: check all variable/field access in modified functions, even if they didn't change
  - Output: list each variable/field access checked with location
- step 4: trace variable/field access to make sure they are initialized before use
  - writing structure members, or passing to functions that only write without reading, counts as initializing
  - Output: list each variable/field showing where it was initialized
- step 5: special attention for error paths (goto fail)
  - Output: list each error path with its label/location
- step 6: if you can't verify fully, check against other similar usage

**After analysis:** Issues found: [none OR list]
