# EH-001: NULL safety verification

**Risk**: NULL deref

**When to check:** Mandatory when pointers are dereferenced

**Note:**

- ERR_PTR() holds an error cast to a pointer, but they are not valid pointers
  - foo = ERR_PTR(-ENOMEM) ; if (foo) -> TRUE, but *foo will CRASH

**Note:** Load patterns/null.md for NULL pointer dereference guidance.
You often confuse reading pointers with dereferencing pointers.

Place each step defined below into TodoWrite.

**For pointers passed to macros/functions**: load definition to verify if/where dereference occurs.

**Mandatory NULL safety validation**:
- Step 0: Identify every pointer, add into TodoWrite
  - Output: name and location
  - Process every pointer in modified functions, even in areas that were not changed.
  - We do this because even small changes can introduce bugs elsewhere in the code.  The
    only way to know is to check all of the code.
- Step 1: Use MULTI_POINTER_MEMORY_TRACKING from CS-001 if available
- Step 2: Never dereference potentially NULL pointers (including in BUG_ON/WARN_ON)
  - Output: list each dereference checked and its NULL safety status
- Step 3: Trace pointers to ensure NULL checks are proper
  - Output: for each pointer, show trace path "ptr from X → passed to Y → dereferenced at Z"
- Step 4: For global/static pointers: search for ALL assignments including NULL
  - Output: list each assignment site found
- Step 5: Verify ERR_PTR()s are not dereferenced
  - Output: list each ERR_PTR and where it flows
- Step 6: If unsure, compare with similar checks in old code (same context only)
  - Output: similar pattern found and comparison result

**After analysis:** Issues found: [none OR list]

**Note**: For tracing NULL passing from callers, see CS-001
