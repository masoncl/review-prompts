# EH-001: NULL safety verification

**Risk**: NULL deref

**When to check:** Mandatory when pointers are dereferenced

**Note:**

- ERR_PTR() holds an error cast to a pointer, but they are not valid pointers
  - foo = ERR_PTR(-ENOMEM) ; if (foo) -> TRUE, but *foo will CRASH

**Note:** Load patterns/null.md for NULL pointer dereference guidance.
You often confuse reading pointers with dereferencing pointers.

**Pattern-specific TodoWrite fields**:
- Pointer: [name] - [type]
- Allocated memory: [ names and offsets of all pointers referencing this memory ]
- Dereference location: [file:line - exact code]
- Dereference type: [direct field access/in function/in macro/in BUG_ON/in WARN_ON]
- If passed to function/macro:
  - Function/macro name: [name]
  - Definition loaded: [YES/NO]
  - Dereferences parameter: [YES/NO]
  - Line in definition that dereferences: [exact code]
- NULL check present: [YES/NO - where]
- NULL check confused with IS_ERR/PTR_ERR: [YES/NO - where]
- Pointer trace: [where from - can be NULL? YES/NO]
- Similar code comparison: [if unsure - snippet and context]
- Registration/export context: [conditions that make code unreachable]

**MANDATORY: Macro and Function Expansion**

Before analyzing each pointer dereference:

For pointers passed to macros or functions, you MUST:
1. Create TodoWrite: "Macro/function expansion for [name]"
2. load the full definition
3. Identify the EXACT operation that dereferences the pointer
4. Document the line within the macro/function where dereference occurs
5. Update your dereference analysis with this information

Example TodoWrite entry:
- Pointer: user
- Passed to macro: netdev_for_each_upper_dev_rcu at line 667
- Macro definition loaded: YES
- Macro dereferences pointer: YES
- Dereference operation: &(dev)->adj_list.upper (accesses dev->adj_list field)

If you cannot load the definition:
- State: "Cannot verify dereference without [macro/function] definition"
- Assume dereference occurs and proceed with NULL check analysis
- Document this limitation in your analysis

**Mandatory NULL safety validation:**
- read entire function and track every pointer access in modified functions in the TodoWrite, even if they didn't change
- Find and use MULTI_POINTER_MEMORY_TRACKING from CS-001.
- never dereference potentially NULL pointers (including in BUG_ON/WARN_ON statements)
- trace pointers to ensure they are checked for NULL properly
- For global/static pointers: search for ALL assignments including NULL assignments
- For API functions: check registration/export to understand when they can be called
- verify ERR_PTR()s are not dereferenced
- if unsure, check to make sure new code maintains similar checks to old code
 - Add similar checks in old code into the TodoWrite
 - Validate the similar checks are being called in exactly the same context
   - BPF context, interrupt, softirq, any locks held, irqs disabled, preemption/migration disabled, etc
   - disregard any similar checks if their contexts are different

**Mandatory Self-verification gate:**

**Pattern-specific questions**:
  1. How many pointer dereferences did you find? [number]

If you cannot answer ALL questions with evidence, RESTART EH-001 from the beginning.

**Note**: For tracing NULL passing from callers, see CS-001
