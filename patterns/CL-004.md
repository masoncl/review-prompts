# CL-004: Race window analysis

**Risk**: Data corruption / Race condition

**When to check**: Mandatory when concurrent access to shared datastructures is possible, or when writes are made to shared resources

Place each step defined below into TodoWrite.

**Part A: Identify concurrent access sites**
- step 1: read entire functions when concurrent access to shared datastructures is possible
  - Output: function name, and a random line from anywhere in each definition
    - you must prove you read the function
- step 2: identify all shared resources being written (state vars, timers, flags, etc.)
  - Check all shared resources in modified functions, even if the resource itself wasn't changed
  - Output: name and location
- step 3: use grep/semcode to find ALL other write sites for same resources
  - Output: quote the actual write code and its location
- step 4: document execution context for each write site (Process/Workqueue/Softirq/Hardirq)
  - Output: execution context found
- step 5: check if new writes can race with existing writes:
  - Softirq can interrupt: process, workqueue
  - Hardirq can interrupt: everything
  - Workqueues can run concurrent with process context

**Part B: Prove race windows exist**
- step 6: verify proper exclusion exists (rcu, locking, atomic ops, memory barriers)
  - Output: exclusion method found or "none"
- step 7: race windows need hard proof showing that both sides of the race can occur in practice
  - do not worry about theoretical races, only proven races
- step 8: trace normal execution without interruption
  - Output: execution sequence (e.g., "A→B→C completes normally")
- step 9: trace potential races assuming interruptions or concurrency at every point in critical sections
  - Output: list interruption points checked
- step 10: think about changes introduced by the patch to potential interruptions or concurrency
  - Output: new race windows introduced or "none"
- step 11: think about parallel execution at every step of unlocked access
  - Output: parallel execution scenarios checked
- step 12: think about compiler reordering of assignments (may need barriers)
  - fooA = fooB; fooC = fooD; might be reordered without barriers in place
  - Output: reordering risks found or "none"

**After analysis:** Issues found: [none OR list]
