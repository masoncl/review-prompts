# BV-001: Bounds and validation at point of use

**Risk**: Buffer overflow

**When to check**: Mandatory when array or buffer indexing occurs

**Pattern-specific TodoWrite fields**:
- Array/buffer: [name] - [type] - [size]
- Index: [expression]
- Bounds check: Present [YES/NO - where], At point of use [YES/NO], Size can change [YES/NO], Revalidation [YES/NO - present?]
- Data source: [trusted/UNTRUSTED]

**Mandatory bounds validation:**
- read full function definitions
- track all index usage in modified functions in TodoWrite, even if they didn't change
- check bounds where data accessed, not just where received
- revalidate if size can change between check and use
- validate untrusted data sources only (don't add defensive checks for trusted data)

**Mandatory Self-verification gate:**

**Pattern-specific questions**:
  1. How many array/buffer indexes did you find? [number]
  2. How many indexes lack bounds checks at point of use? [number]
  3. How many indexes need revalidation but lack it? [number]
  4. Have you verified data source (trusted/untrusted) for EVERY index? [yes/no]

If you cannot answer ALL questions with evidence, RESTART BV-001 from the beginning.

**Notes on common patterns**:
- strscpy() auto-detects array sizes when compiler can find the type
- char \*s = ""; strlen(s) returns zero, but s[0] is safe to access
- memcpy(dst + (offset & mask), src, size) usually has alignment validation elsewhere
- Global arrays with MAX_FOO: check if impossible to create more than MAX_FOO elements
