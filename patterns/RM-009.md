# RM-009: memcg accounting

**Risk**: Incorrect memory accounting

**When to check**: Mandatory when page, slab or vmalloc APIs are used (skip otherwise)

**Pattern-specific TodoWrite fields**:
Notes when memory is allocated under __GFP_ACCOUNT:
- by default most usage charges memory to the task's memcg
- slabs created with SLAB_ACCOUNT implicitly have __GFP_ACCOUNT on every allocation


- Allocation: [API call] at [line]
- Flags: [GFP flags used]
- Memcg charged: [which memcg]
- set_active_memcg() used: [YES/NO] - Context [kthread/BPF map/other] - Pattern shown
- Consistent with surrounding code: [YES/NO - explain]

**Mandatory memcg accounting validation:**
- step 1: read entire function definition
- step 2: when using __GFP_ACCOUNT, ensure the correct memcg is charged
  - old = set_active_memcg(memcg) ; work ; set_active_memcg(old)
- step 3: most usage does not need set_active_memcg(), but:
  - helpers operating in kthreads switching context between many memcgs may need it
  - helpers operating on objects (ex BPF maps) that store an memcg to be charged against at creation time may need it
- step 4: ensure new __GFP_ACCOUNT usage is consistent with the charging model used in the rest of the surrounding code

**Mandatory Self-verification gate:**

**Pattern-specific questions**:
  1. How many __GFP_ACCOUNT usages did you find? [number]
  2. How many usages charge the wrong memcg? [number]
  3. How many usages need set_active_memcg() but don't use it? [number]
  4. How many usages are inconsistent with surrounding code? [number]

If you cannot answer ALL questions with evidence, RESTART RM-009 from the beginning.
