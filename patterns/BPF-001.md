# BPF-001: Special BTF field handling in map operations

**Risk**: Map copy/update operations omitting check_and_init_map_value() or bpf_obj_free_fields() calls, causing uninitialized special fields or resource leaks

**When to check**: Mandatory when any map lookup/update operations are added or modified that use copy_map_value() or copy_map_value_long()

Place each step defined below into TodoWrite.

**Mandatory BTF field handling validation:**

**Step 1**: Identify all map operations that copy values in the diff
  - Add each map operation to TodoWrite, do not complete the TodoWrite entry until
    all steps are done.
  - Output: list each map operation by name and location
  - Search for functions using copy_map_value() or copy_map_value_long()
  - Place into TodoWrite all functions matching common patterns:
    - Percpu operations: bpf_percpu_*_copy, bpf_percpu_*_update, pcpu_copy_value
    - Regular operations: *_map_lookup_elem, *_map_update_elem
    - Batch operations: *_map_lookup_batch, *_map_update_batch
    - New map type implementations (map_ops->map_lookup_elem, map_ops->map_update_elem)
  - Include the map type each function operates on (check for BPF_MAP_TYPE_* references)
  - Note whether operation is percpu or regular (affects reference implementations to check)

**Step 2**: Determine if the map type supports special BTF fields
  - Find and read the map_check_btf() function in kernel/bpf/syscall.c
  - This function contains switch statements checking field_mask for different field types
  - Search for the for loop that iterates through field_mask bits (look for "for (i = 0; i < sizeof(map->record->field_mask)")
  - For each special field type case, examine the map type allowlist that follows:
    - Search for "case BPF_SPIN_LOCK:" - check the following if statement for allowed map types
    - Search for "case BPF_TIMER:" - check the following if statement for allowed map types
    - Search for "case BPF_KPTR_UNREF:" or "case BPF_KPTR_REF:" - check for allowed map types
    - Search for "case BPF_LIST_HEAD:" - check for allowed map types
    - Search for "case BPF_UPTR:" - check for allowed map types
    - **IMPORTANT**: New field types may be added over time. Read the ENTIRE switch statement
      in map_check_btf() and check ALL case statements, not just the ones listed above.
      If you find case statements not listed here, include them in your analysis.
  - Each case has an if statement like: `if (map->map_type != TYPE1 && map->map_type != TYPE2 ...)`
  - The types listed in these conditions are the ONLY types that can have those fields
  - Note: Non-percpu and percpu variants of the same map type may have different restrictions
  - IMPORTANT: If the map type is NOT in any allowlist, it CANNOT have special BTF fields
  - Add evidence to TodoWrite: [map type] - [can have fields: yes/no] - [which fields allowed]

**Step 3**: For each copy operation (kernel→userspace), verify check_and_init_map_value() usage
  - Add copy operation to TodoWrite
  - Output: copy operation name and location
  - Identify copy_map_value() or copy_map_value_long() calls where destination is the userspace buffer
  - Pattern: `copy_map_value(map, userspace_buf, kernel_ptr)` or similar
  - If map type supports special BTF fields (Step 2), verify:
    - check_and_init_map_value(map, userspace_buf) is called AFTER the copy operation
    - This initializes spin locks, timers, kptrs in the copied data
  - Compare with reference implementations based on operation type:
    - For percpu maps, search for: bpf_percpu_array_copy(), bpf_percpu_hash_copy()
    - For regular maps, search for: array_map_lookup_elem(), htab_map_lookup_elem()
    - For batch operations, search for generic_map_lookup_batch()
    - All should call check_and_init_map_value() after copying to userspace
  - If map type DOES NOT support special fields, missing call is OK (not a bug)

**Step 4**: For each update operation (userspace→kernel), verify bpf_obj_free_fields() usage
  - Add update operation to TodoWrite
  - Output: update operation name and location
  - Identify copy_map_value() or copy_map_value_long() calls where destination is kernel storage
  - Pattern: `copy_map_value(map, kernel_ptr, userspace_buf)` or similar
  - If map type supports special BTF fields (Step 2), verify:
    - bpf_obj_free_fields(map->record, kernel_ptr) is called AFTER the copy operation
    - This cleans up old timers, kptrs before they get overwritten
  - Compare with reference implementations based on operation type:
    - For percpu maps, search for: bpf_percpu_array_update(), pcpu_copy_value()
    - For regular maps, search for: array_map_update_elem(), htab_map_update_elem()
    - For batch operations, search for generic_map_update_batch()
    - All should call bpf_obj_free_fields() after copying from userspace
  - If map type DOES NOT support special fields, missing call is OK (not a bug)

**Step 5**: Check for false positive conditions
  - Verify you checked the EXACT map type (percpu vs non-percpu variants matter!)
  - Verify the allowlist in map_check_btf() applies to this specific map type
  - If uncertain, search for map_type enum value in map_check_btf() function body

**After analysis:** Issues found: [none OR list]

**Common false positive scenarios:**
- Map types not in map_check_btf() allowlists (e.g., BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)
- Confusing percpu and non-percpu variants (e.g., CGROUP_STORAGE vs PERCPU_CGROUP_STORAGE)
- Assuming all maps support special fields (most do not!)
- Not checking the actual kernel source for current allowlists

**Evidence required to report:**
- Exact map type enum value
- Proof from map_check_btf() that this map type CAN have special fields
- Comparison with reference implementation showing the pattern
- Concrete scenario where the missing call causes a bug
